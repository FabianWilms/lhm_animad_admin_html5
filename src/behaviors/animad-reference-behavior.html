<script>
    let AnimadReferenceBehavior = (superclass) => class extends superclass {
        static get properties() {
            return {
                /*
                 *
                 */
                sourceUrl: {
                    type: String
                },
                /*
                 * 
                 */
                source: {
                    type: Array,
                    value() {
                        return [];
                    }
                },
                /*
                 *
                 */
                 _selected: {
                    type: Array,
                    value() {
                        return [];
                    }
                },
                /*
                 * 
                 */
                preload: {
                    type: Boolean,
                    value: false
                },
                /*
                 *
                 */
                saveRelationById: {
                    type:Boolean,
                    value: false
                },
                // TODO delete - i18n
                label: {
                    type: String,
                    value: "Booo"
                },
                /*
                 * Property des geladenen Objekts, das den 
                 * anzuzeigenden Text enthält.
                 */
                textProperty: {
                    type: String,
                    value: "text"
                },
                /*
                 * Property das die ID des Objekts enthält.
                 */
                valueProperty: {
                    type: String,
                    value: "value"
                }

            }
        }

        connectedCallback() {
            super.connectedCallback();
            // Wenn gewünscht, wird der content
            // beim Erstellen der Komponente vorab
            // vom Server geladen.
            if(this.preload) {
                this._loadReferenceData();
            }

            // Es muss ein eventlistener registriert werden,
            // um die selektierten Elemente verarbeiten zu
            // können.
            var e = this.shadowRoot.querySelector('paper-autocomplete');
            e.addEventListener('autocomplete-selected', this._appendItem);
        }

        _appendItem(event) {
            // Der 'host' des Elternknotens wird benötigt
            // um an die Properties zu kommen.

            var h = this.parentNode.host;
            var name = 'data.' + h._entity + 's';
            var id = event.detail.value;

            // Wenn noch kein Attribut vorhanden ist, um
            // die Referenz zu speichern, so muss eines 
            // mit einem leeren Array erzeugt werden.
            if(!h.parentNode.get(name)) {
                h.parentNode.set(name, []);
            }

            // Wenn das Property 'save-relation-by-id' gesetzt ist...
            if(this.saveRelationById) {
                // Der key der ausgewählten Referenz wird
                // im Array gespeichert.
                h.parentNode.push(name, id);
            } else {
                // Das Relationsobjekt wird gespeichert
                h.parentNode.push(name, this.source.find(x => x.value === id).item);
            }

            // Textfeld leeren
            event.currentTarget.clear();
        }

        _removeItem(event) {
            // Der 'host' des Elternknotens wird benötigt
            // um an die Properties zu kommen.
            var h = this.parentNode.host;
            var name = 'data.' + h._entity + 's';


        }

        _loadReferenceData() {
            var headers = new Headers();
            headers.append("Content-Type", "application/json");
            headers.append("Accept", "application/json");

            var init = {
                method: 'GET',
                headers: headers,
                mode: 'cors',
                cache: 'default'
            };

            // create request object
            var request = new Request(this.sourceUrl, init);

            // call the server
            fetch(request)
                .then(response => {
                    if (response.ok) {
                        //console.log(response);
                        response.json().then(body => {
                            // Bei Erfolg werden die Daten, die vom Server kommen 
                            // in eine key/value liste umgewandelt und im Array
                            // Property 'source' gespeichert.
                            for (var i = 0; i < body.length; i++) {
                                this.source.push({
                                    "text": body[i][this.textProperty],
                                    "value": body[i][this.valueProperty],
                                    "item": body[i]
                                })
                            }
                        })
                    } else {
                        this._error(response.status);
                    }
                });
        }
    }
</script>